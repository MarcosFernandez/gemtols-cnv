#!/usr/bin/env python
# countKmerMappings.py Get kmer mappings for those regions with no Ns in the sequences and at least 2 hits
#
# Usage:
#   countKmerMappings.py -kmersMap <kmersMap> -kmersCount <kmersCounts>
#
# Inputs:
#    -kmersMap <kmersMap>        Path to map file generated by gem
#
# Outputs:
#    -kmerCounts <kmerCounts>    Kmer Counts output

import sys, argparse
import os.path
import glob
import re

def areNs(line):
    ''' Any line wit an N is rejected, return True '''
    for base in line:
        if base == 'n' or base == 'N':
            return True
    return False 

def getInteger(value):
    '''Returns integer value or 0 in case is not possible to get the integer value'''
    try:
        intValue = int(value)
        return intValue
    except ValueError:
        return 0

#PARSING ARGUMENTS
parser = argparse.ArgumentParser(description='Count kmer mappings to look for overrepresented kmers (more than 20 mappings into the assembly)')
parser.add_argument('-kmersMap', metavar='kmersMap', help='Path to map file generated by gem',
                    required=True)
parser.add_argument('-kmersCount', metavar='kmerCount', help='Kmer Counts output',
                    required=True)

args = parser.parse_args()

#0. OPEN OUTPUT FILE
with open(args.kmersCount, 'w') as countFile:

#1. PROCESS MAPPING OUTPUT 
    with open(args.kmersMap, 'r') as mapFile:
        #1.1. Get those reads than have no Ns
        for mappingLine in mapFile:
            fieldsName = re.split('\s+', mappingLine.rstrip('\n'))
            if areNs(fieldsName[1]) == False:
                counts = getInteger(fieldsName[2])
                if counts > 1:
                    locations =  re.split('[:-]', fieldsName[0]) 
                    countFile.write(locations[0] + "\t" + locations[1] + "\t" + locations[2] + "\t" + fieldsName[1] + "\t" + fieldsName[2] + "\n")

